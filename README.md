# javaexam
Экзамен по Java.
Коробейников Дмитрий Александрович.
Какова разница между абстрактным классом и интерфейсом?
Абстрактный класс – класс, часть методов которого не имеют реализации. Соответственно, мы не можем создавать экземпляры данного класса, но можем наследоваться от него, чтобы затем у потомков (или потомков потомков) реализовать нереализованные (абстрактные) методы.
Использование абстрактных классов используется в том случае, когда у нас есть несколько классов, которые являются потомком одного класса,  и у которых есть одинаковые методы, но, при этом, исходный класс слишком общий, чтобы хоть какая-нибудь осмысленная реализация данного метода была уместна.

Интерфейс – класс, все методы которого являются абстрактными. А так же public.
Интерфейсы используются для добавления классу определенной функциональности, не связанной напрямую с его иерархией наследования. Соответственно, в классе должны быть реализованы  все методы, описанные в интерфейсе. Например, интерфейс Cloneable содержит абстрактный метод clone, позволяющий создавать копию объекта. Мы можем применить этот интерфейс к совершенно не связанным между собой классам, например Pen и Animal, и все они будут реализовывать clone. Разумеется, реализация у каждого класса будет своя, и она будет описана в его теле.

Разница между ними заключается в том, что у класса может быть лишь один предок. Мы не можем отнаследоваться сразу от нескольких классов. Интерфейсов же класс может реализовать неограниченное количество. Также, часть методов абстрактного класса могут иметь реализацию, тогда как интерфейс полностью абстрактен. 


Как «насильно» вызвать сборку мусора?
В Java у классов нет деструкторов. За освобождение памяти отвечает Garbage Collector, который в фоновом режиме следит за использованием памяти, и время от времени уничтожает ненужные объекты.
Мы можем реализовать в наших классах метод finalize, который будет вызван сборщиком мусора непосредственно перед уничтожением объекта. В нем мы можем, например, закрыть соединение, поток ввода-вывода, для корректного завершения работы.
Но слишком сильно полагаться на данный метод не стоит, поскольку при сильной загруженности системы сборщик мусора может начать игнорировать блоки finalize.
Для “насильной” сборки мусора мы можем вызвать System.gc() или Runtime.getRuntime().gc().

Когда требуется явное приведение классов?
Явное приведение классов требуется в ситуации, когда приводимый и, соответственно, класс, к которому мы хотим привести, находятся в одной иерархии наследования.
Вспоминая пример из лекции, пусть у нас будет класс Human и класс Doctor, который является наследником класса Human. Мы можем спокойно написать
Human human = new Doctor();
Поскольку это будет сужением возможностей, ведь Doctor реализует все поля и методы Human.
В обратной же ситуации нам понадобится явное приведение, поскольку мы расширяем возможности.
Doctor doctor = (Doctor) new Human();






Чем конструкторы отличаются от других методов?
Конструктор – метод, который вызывается для создания объекта данного класса.
У метода-конструктора нет возвращаемого значения.
Его имя должно совпадать с именем класса. Как и с обычными методами, конструкторов может быть несколько с различными сигнатурами (перегрузка).
В случае, если у данного класса есть предок, то обязательно первой строчкой в конструкторе должен идти вызов конструктор класса-родителя. Для этого используется ключевое слово super(список аргументов). В принципе (о чем будет разговор в следующем вопросе), не обязательно начинать конструктор с super. Можно вызвать в нем другой конструктор того же класса. Это удобно в случае, если у нас есть несколько необязательных, к примеру, полей, и вся разница между конструкторами заключается в инициализации этого поля.
Главное чтобы в итоге каждый конструктор так или иначе вызвал super.
В том случае, если у класса нет ни одного реализованного конструктора, ему автоматически создастся пустой конструктор без входных аргументов. Это называется конструктором по умолчанию.

Можно ли вызывать конструкторы один из другого, если их в классе несколько?
Да, можно, используя ключевое слово this.
Я приведу пример, который одновременно подходит для предыдущего вопроса.

Class Rectangle extends Figure{
  Public Int a, b;
  Public Rectangle(int a, int b){
     Super();
     This.a = a;
     This.b = b;
  }
Public Rectangle(int a){
     This(a,a);
  }
}

В данном случае я реализовал новый конструктор, используя код уже существующего, без дублирования.

	
В чем разница между JDK и JRE?
JDK – Java Development Kit. Набор программ для разработчика, состоящий из JVM, компилятора Java, архиватора jar, javadoc, и других.
 
JRE – Java Runtime Environment – среда выполнения уже готовых java-приложений, в которой содержится только JVM и стандартные библиотеки.

Соответственно, разница заключается в том, что в JRE мы можем лишь запускать приложения, тогда как в JDK мы имеем возможность их компилировать, архивировать и прочее.

Имеет ли значение в каком порядке перехватывать исключения FileNotFoundException и IOExceptipon?
Да, имеет. FileNotFoundException является наследником IOExceptipon.
Если мы напишем код вида 
Try{
…
}
Catch (IOExceptipon e) {
}
Catch(FileNotFoundException e){
}

, то во второй блок catch мы не попадем (мы сейчас не говорим про “пробрасывание” исключений), поскольку оба вида ошибок будут пойманы первым блоком catch, поскольку FileNotFoundException можно привести к IOExceptipon. 
Если же мы хотим действительно ловить ошибки в соответствии с их типом, то нам нужно выстраивать структуру блоков catch, начиная обходить дерево иерархии наследования ошибок снизу.

Могут ли внутренние классы, описанные внутри метода, иметь доступ к локальным переменным этого метода?
Да, могут. Так же как и классы, описанные внутри класса, имеют доступ к полям данного класса.

Как подкласс может обратиться к методу или конструктору из суперкласса?
С помощью специального слова super.
К конструктору, как уже говорилось ранее, в виде super(список аргументов).
А к методу в виде super.getValue(), например.


В чем разница между очередью и стеком?
Разница в принципе хранения данных и доступных методах.

Очередь (Queue) реализует принцип FIFO (first in – first out). Кто первый помещен в очередь, то первый и выйдет из очереди. Собственно, потому такое и название. Мы помещаем объекты в конец очереди, а достаем из начала. 

Стек (Stack) реализует принцип LIFO (last in – first out). Мы достаем последний помещенный элемент. 

Стек используется, например, при многократном вызове процедур одна из другой, когда текущий контекст мы помещаем в стек, чтобы по окончании процедуры достать его обратно, и так далее.

Что вам приходит в голову, когда вы слышите о новом поколении (young generation) в Java?
Garbage Collector, сборка мусора, выделение памяти.

Есть два класса: A и B. Класс B должен информировать класс A когда случается некое важное событие. Какой design-pattern вы должны реализовать?
Creator, поскольку информирование это, по сути, вызов какого-то метода A, соответственно, B должен иметь доступ к объекту класса A.


Какой модификатор доступа надо указать в классе, чтобы доступ к нему имели только классы из того же пакета?
Существует три модификатора.
Public – виден всем
Protected – виден наследникам
Private – не виден снаружи

В данном случае не нужен вообще никакой модификатор.

Чем отличается статический внутренний класс от просто внутреннего класса?
Статический класс, как и любое статическое поле, принадлежит классу, а не объекту.
Соответственно, для обращения к нестатическим полям внешнего класса нам нужен объект внешнего класса, тогда как к статическим полям мы можем обращаться.
Мы можем обращаться к статическим методам внутреннего класса, используя полное имя.

можно ли обратиться к не-статической переменной из статического метода?
Нет, нельзя. Опять же, статический метод принадлежит классу, тогда как не-статическая переменная принадлежит объекту. Мы не можем обратиться к ней, поскольку все объекты класса имеют одни и те же статические поля.
какие типы данных есть в Java?
Ссылочные и примитивные.
К ссылочным относятся объекты.
К примитивным относятся целые и дробные числа, символы и логические переменные.

Ключевая разница между этими двумя типами заключается в том, что первые передаются, как следует из названия, по ссылке, а вторые по значению.

В момент передачи переменной, к примеру, целого типа, в метод, в методе создается копия этой переменной, с которой и происходит какая-то работа, в том числе изменения. На исходную переменную это никак не повлияет. Если мы действительно хотим, чтобы значение поменялось, нам придется использовать класс-обертку для данного типа.

Ссылочные типы содержат в себе лишь ссылку на объект, плюс информацию о типе объекта.
Это значит, что если написать, к примеру, a=b, то мы получим две ссылки на один и тот же объект.
Также, в отличие от примитивных типов, сравнение a==b покажет лишь ссылаются ли обе переменные на один объект или нет. Для сравнения по значению для ссылочных типов используют метод equals.

Чем отличаются переопределение (Override) и перегрузка (Overload)
Override – переопределение метода предка у потомка. Мы пишем новую реализацию для метода с сигнатурой, совпадающей с таковой у предка.
К примеру, все классы являются наследником Object, у которого есть метод toString.
В своем классе мы можем написать свою реализацию данного метода, которая будет вызываться при использовании .toString у объектов данного класса.

Overload – перегрузка метода данного класса. Мы пишем метод, у которого совпадает имя с одним из уже существующих методов нашего класса, но отличается список параметров.
К примеру, у нас в классе есть функция
Int sum(int a, int b), которая возвращает сумму двух чисел.
Мы можем реализовать метод
Int sum(int a, int b, int c), который будет возвращать сумму уже трех чисел.
Можем написать double sum(double a, double b).
Это удобно в том случае, когда нам нужно сделать одинаковые по смыслу действия для различных входных параметров.
Например, очень часто перегружают конструктор, позволяя инициализировать объект класса несколькими различными способами.

Что такое итератор?
Итератор – объект специального типа, предназначенный для обращения к объектам коллекции.
Имеет три метода.
hasNext() – проверка того, что следующий элемент коллекции существует.
getNext() (не уверен, что так называется) – возвращает следующий элемент коллекции.
Remove() – удаляет текущий элемент коллекции.

В отличие от конструкции foreach, дает возможность удалять элементы.

Перечислите основные категории исключительных ситуаций
Error, Exception.

Error – ошибка, вызванная внешними причинами (закончилось место на жестком диске).
Exception – ошибка в программе. Может быть проверяемой или непроверяемой (Runtime).
Соответственно, проверяемые мы можем попытаться поймать с помощью try/catch.



Какая разница между throw и throws?
Throw – выбросить ошибку. Если мы поняли, что в работе нашей программы что-то пошло не так, мы можем самостоятельно написать конструкцию throw new Exception(). Разумеется, ошибка может быть более конкретного класса, или даже созданного нами самими класса ошибки.
Соответственно, мы поймаем её в блоке catch, и должны будем как-то её обработать.

Throws говорит о том, что наш метод или класс может генерировать ошибку данного (данных) типа, но он её не обрабатывает. Соответственно, тому, кто будет использовать данный метод или класс, нужно будет тоже писать конструкцию try/catch. С помощью этого перечисления мы сообщаем ему, какие ошибки нужно быть готовым ловить.
Выглядит описание метода так: 
void method throws (список классов ошибок) (список аргументов){
…
}

Зачем нужен блок finally?
Finally – ключевое слово, которое используется последним в конструкции try/catch.
Выглядит это так:

Try{
..
}
Catch(ошибка какого-то типа){ 
}
Catch(ошибка какого-то другого типа){ 
}
…
Finally{
…
}

В блоке finally содержится, код, который должен будет выполнен в любом случае, вне зависимости от того, случилась ошибка или нет. В таком блоке, например, можно закрывать потоки данных, соединение с базой данных.
С потоками можно использовать конструкцию try-with-resources.
Для этого нужно написать try(  здесь создать переменную потока), и, если переменная реализует интерфейс AutoCloseable, то поток будет закрываться автоматически.

Что такое finalize?
Finalize – метод, который будет вызван Garbage Collector перед уничтожением объекта.
Мы должны сами его написать для нашего класса, и в нем позаботиться о том, чтобы все сторонние ресурсы, которые использовал наш объект, были корректно закрыты. Как уже говорилось ранее, данный метод на самом деле является не самым надежным, поэтому лучше закрывать ресурсы программно заранее.

Перечислите все виды внутренних классов
Статические, не статические.
